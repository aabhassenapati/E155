---
title: "Lab 3: Keypad Scanner"
description: "Here I document my work on the lab 3 of MicroPs, where I work with FPGA and a 4*4 keypad to display digits on a  dual seven segment display."
date: "09/18/25"
categories:
  - labs 
  - FPGA
  - e155
author: Aabhas Senapati
draft: false
---

## Introduction

I this lab I try to design a system that can read inputs from a 4*4 keypad through debouncing the inputs, and display the entered digits with time multiplexing on a dual seven segment display displaying inputs.

## Design and Testing Methodology
 I designed 8 modules in Verilog to implement my hardware on the FPGA, where my top module interfaces with the modules that divide the clock signal into lower frequencies as need, module to have counters keeping track of what keys are pressed, and fsm module that determine which key press to assert and synchronize it to the display, and module to drive the segment enablers and digits. 

My specific design approach was to power the 4 rows of the keypad one by one on a divide by 4 counter, and then read all the four corresponding column inputs while powering the respective rows, and check if the switch is pressed by looking for a high and increment a counter. My logic for the debouncing of switch press, to detect it accurately was that, if my sampling is fast enough (24Mhz, lower should also work), and the sampling period appropriately small enough chosen (50ms/20Hz), to reset the counters, I can find out which key was pressed, based on the counter with highest value, that would be the actual key pressed, as if any key is pressed later, it would have a lower counter value for being detected as on. The highest counter value is then provided to the keypress detection fsm which when the highest counter is above a certain threshold, it registers it as a valid input, and makes it a locked counter, and outputs a key_pressed pulse, and the key id and gives it to the display moudle. This helps both debounce and synchronize the inputs into our system before they reach the segments. The fsm stays in locked state, untill the locked key has counter value above threshold, and when it goes below threshold it registers it as switch release and thus goes back to idle state to detect new inputs. For the segments, I drive the multiplexer at 240Hz, to enable one segment on clock high and other on low, and then the key pressed pulse, and key_pressed signals from the fsm go to the segment display to update the digits each time a new key press is detected.

I think my design was pretty simple to think about in terms of logical flow, and did not require a lot of states to be able to do debouncing, but while it was easier to think and execute, I think it was very hardware intensive given the redundancy in the approach and some hardware that could be simplified and avoided. Like I used 16 counters each for the corresponding switch, which given that I am sampling at really high frequency is a lots of samples within 50 ms, therefore two ways to mitigate this resource usage would be one, just keep track of the counter of the key that was first pressed, and also reducing the clock speed so that I do not have a lot of samples, and yet be able to register distinct inputs without significant latency. I think the basic tradeoff in my design was ease of conceptual design vs hardware resource usage, and in future working towards the other goal of hardware efficiency might be important thinking about while making my design. I do personally like the method I implemented as it is pretty elegant in terms of logical flow as I conceptualize it. This strategy that I adopted also removed the need of explicit synchronizers as the scanning duration from these counters itself allowed time for signals to stabilize and also have enough samples to not have to worry about initial possible metastable states, and as it goes through fsm it schronizes with the clock and goes as input correctly to the display module.

 
 My calculations for resistor values used in the circuit to connect inputs, seven-segment, and transistors can be found as below.

![](images/lab3_calculation0.jpg)

![Fig. 1: Calculations for resistor values](images/lab2_calculation1.jpg)

## Technical Documentation

### Block Diagram

![Fig. 2: Block Diagram for top module "lab3_as"](images/lab3_block_diagram.png) 


### Schematic

![Fig. 3: Schematic for Hardware Setup](images/lab3_schematic.jpg)

### State Transition Diagram and Table

![Figure. 4aState Transition Diagram for the power_counter fsm](images/fsm0.jpg)

![Figure. 4b State Transition Diagram for the read_keys fsm](images/fsm1.jpg)

![Figure. 4c State Transition Diagram for the keypress detection fsm](images/fsm2.jpg)

![Figure. 5a State Transition Table for the power_counter fsm](images/transitiontable0.jpg)

![Figure. 5b State Transition Table for the read_keys fsm](images/transitiontable1.jpg)

![Figure. 5c State Transition Table for the keypress detection fsm](images/transitiontable2.jpg)

### HDL Code

[Can be found on github repository](https://github.com/aabhassenapati/E155-labs/tree/main/lab3/fpga)

<script src="https://gist.github.com/aabhassenapati/befb30ad17991d8b391cf60530fa9dce.js"></script>

<script src="https://gist.github.com/aabhassenapati/f392c8c00f720906aad23f97a5dc2fe7.js"></script>

<script src="https://gist.github.com/aabhassenapati/0df92b0f0d819a72a4e63207f37d6485.js"></script>

<script src="https://gist.github.com/aabhassenapati/88ab956f47daf057dbb98d1782bce34d.js"></script>

<script src="https://gist.github.com/aabhassenapati/78e8fbfad51bba2a59eb271122e049ae.js"></script>

<script src="https://gist.github.com/aabhassenapati/671965134589f05adcb682a3042d2def.js"></script>

<script src="https://gist.github.com/aabhassenapati/eb130264653f9d598157c969648f2d8e.js"></script>

<script src="https://gist.github.com/aabhassenapati/003b4185fc147017ba1eb1614972f10d.js"></script>

## Results and Discussion

![Fig. 6: Hardware Setup working](images/lab3_hardware.png)


### Testbench Code

<script src="https://gist.github.com/aabhassenapati/05684ebe99fc8d3598e5f9617e9d0335.js"></script>

<script src="https://gist.github.com/aabhassenapati/a930bbff9b18c8952f9027760ec21df6.js"></script>

<script src="https://gist.github.com/aabhassenapati/28eb8e87326967665c2add7923b7b0ca.js"></script>

<script src="https://gist.github.com/aabhassenapati/bf61242a2d0f35bce734e713e311f105.js"></script>

<script src="https://gist.github.com/aabhassenapati/36026a85a9bf496162fbe91cb3853999.js"></script>

<script src="https://gist.github.com/aabhassenapati/fe3921921a3ff91c4456162e6a51254d.js"></script>

<script src="https://gist.github.com/aabhassenapati/9af99285258e4322a4ebfeed54115c20.js"></script>

<script src="https://gist.github.com/aabhassenapati/1abeac2c4f45b04c5d874fb13d335c5a.js"></script>

### Testbench Simulation Results

![Fig. 7: Waveforms for top module lab3_as](images/tb_top_waveforms.png)

![Fig. 8: Waveforms for module clock_divider](images/tb_cd_waveforms.png)

![Fig. 9: Waveforms for module power_counter](images/tb_pc_waveforms.png)

![Fig. 10: Waveforms for module scan_counter](images/tb_sc_waveforms.png)

![Fig. 11: Waveforms for module read_keys](images/tb_rk_waveforms.png)

![Fig. 12: Waveforms for module keypress_detection_fsm](images/tb_kdf_waveforms.png)

![Fig. 13: Waveforms for module seg_enabler](images/tb_se_waveforms.png)

![Fig. 14: Waveforms for module seg_display](images/tb_sd_waveforms.png)

![Fig. 15: Testbench output for top module lab3_as](images/tb_top_output.png)

![Fig. 16: Testbench output for module clock_divider](images/tb_cd_output.png)

![Fig. 17: Testbench output for module power_counter](images/tb_pc_output.png)

![Fig. 18: Testbench output for module scan_counter](images/tb_sc_output.png)

![Fig. 19: Testbench output for module read_keys](images/tb_rk_output.png)

![Fig. 20: Testbench output for module keypress_detection_fsm](images/tb_kdf_output.png)

![Fig. 21: Testbench output for module seg_enabler](images/tb_se_output.png)

![Fig. 22: Testbench output for module seg_display](images/tb_sd_output.png)


## Conclusion
 I was able to succesfully achieve all the goals for this lab to read all the different key inputs from the 4*4 keypad, with debouncing so that it never double registers a key press, and also doesn't register multiple keypresses, untill the initially clicked keys are released. I think it was very intresting to think about the debouncing logic and implementing in the hardware, especially how in some places different aspects like paralllelizing the logic can be critical to not violate setup time constrains in case of complexx logic, and other possible synchronization errors that can happen with asynchronous input to the system. I was very happy to be able to make my initial design work in the first attempt itself except some fine tuning for time, and in further labs I would like to think more about making my logic more efficient as well. I spent about 25 hours on this lab.

## AI Prototype 

Upon entering the given prompt the initial AI generated code that syntehsized on first go itself, for both the prompts, this shows the versatality of these tools to not only geenrate fresh code, but also use our code, and adapt its logic to build upon it, which is very helpful in real world project development, where nothing is built from scratch but rather a progressive increment on existing work. It is pretty cool to see how easily can AI accelerate the workflow for hardware development related projects. I am attaching below RTL synthesis for the AI geenrated code. It also turns out the synthesis that AI generated was much more resource efficient and used much lesser LUTs onboard, thus it hints that AI could be a great tool to increase efficiency of designs. I also think that the AI is limited in terms of ability to get feedback from real-time deployment of design onto hardware and thus nudge it in terms of timing and other nuance which it might lack.

![](images/ai_rtl1.png)

![Fig. 23: RTL synthesis for AI generated Code](images/ai_rtl2.png)

