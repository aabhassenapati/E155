[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflections\n\n\nHere I document my first, thoughts, goals, and some initial reflections about E155 course I am taking this semester\n\n\n\n\n\nAug 29, 2025\n\n\nAabhas Senapati\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "I this lab I try to design a dual seven segment display displaying inputs by two 4-bit dip switches, and using only one seven-segment decoder, by time-multiplexing the output."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "I this lab I try to design a dual seven segment display displaying inputs by two 4-bit dip switches, and using only one seven-segment decoder, by time-multiplexing the output."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nI designed four modules in Verilog to implement my hardware on the FPGA, where my top module interfaces with the modules that divide the clock signal using a counter, add the two switch inputs using a adder, and also a module that drives the dual seven segment display through time multipleixng. In my clock_divider module, I used a counter to divide my clock signal from 24Mhz to 240 Hz. In the four_bit_adder module, I added the two 4-bit switch inputs to give a 5-bit sum output that is displayed on leds. In the dual_sevenseg module a mux switches the inputs to the decoder for seven segment, based on the divided clock signal, and reset.\nMy calculations for resistor values used in the circuit to connect leds, seven-segment, and transistors can be found as below.\n\n\n\n\nFig. 1: Calculations for resistor values"
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nBlock Diagram\n\n\n\nFig. 2: Block Diagram for top module “lab2_as”\n\n\n\n\nSchematic\n\n\n\nFig. 3: Schematic for Hardware Setup\n\n\n\n\nHDL Code"
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\n\nFig. 4: Hardware Setup working\n\n\n\n\n\nFig. 5: RTL Synthesis for the top module\n\n\n\nTestbench Simulation\n\n\n\n\n\n\n\nFig. 6: Waveforms for top module lab2_as\n\n\n\n\n\nFig. 7: Waveforms for module clock_divider\n\n\n\n\n\nFig. 8: Waveforms for module four_bit_adder\n\n\n\n\n\nFig. 9: Waveforms for module drive_dual_sevenseg\n\n\n\n\n\n\nFig. 10: Testbench Output for module lab2_as\n\n\n\n\n\nFig. 11: Testbench Output for module clock_divider\n\n\n\n\n\nFig. 12: Testbench Output for module four_bit_adder\n\n\n\n\n\nFig. 13: Testbench Output for module drive_dual_sevenseg"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI was able to succesfully achieve all the goals for this lab to display sum of two switch inputs on leds, and time-multiplexed display of inputs on the dual seven segment. I learnt how to use an FPGA and to time-multiplex outputs and drive multiple hardware periperhals using same internal hardware. I spent like approximately 15 hours on this lab. I also found it helpful to modularize my code to make it easier to have full coverage on modules, and better idiomatic representation of logic."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\nUpon entering the given prompt the initial AI generated code that syntehsized on first go itself, for both the prompts, this shows the versatality of these tools to not only geenrate fresh code, but also use our code, and adapt its logic to build upon it, which is very helpful in real world project development, where nothing is built from scratch but rather a progressive increment on existing work. It is pretty cool to see how easily can AI accelerate the workflow for hardware development related projects. I am attaching below RTL synthesis for the AI geenrated code.\n\n\n\n\nFig. 14: RTL synthesis for AI generated Code"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "I this lab I try to design a seven segment display controlled by dip switche and designed the hardware and software for making this project possible."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "I this lab I try to design a seven segment display controlled by dip switche and designed the hardware and software for making this project possible."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nI designed three modules in Verilog to implement my hardware on the FPGA, where my top module interfaces with the modules that drive builtin leds and seven segment display. In my led builting module, I used a counter to divide my clock signal from 24Mhz to 2.4 Hz, meanwhile for the other two leds based on the truth table, i implemented the outputs to leds as XOR and AND gates respectively. In the seven segment module I wrote the case based switching based on switch inputs to drive the leds on seven segment, that implements it as combinational logic. I calculated my resistor values by doing Vdd-Vf(led)=IR, i.e. 3.3V - 2.1V = IR, and tried to limit my current below 8mAmps, for convinience I used the 162 Ohm resistor, which satisfies this requirement, as current flowing should be around 7.4 mAmps. The implementation was tested with simulation testbenches on Questa, and also verified on actual hardware built as shown below, using the schematics."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nBlock Diagram\n\n\n\nFig. 1: Block Diagram for top module “lab1_as”\n\n\n\n\nSchematic\n\n\n\nFig. 2: Schematic for Hardware Setup\n\n\n\n\nCode"
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\n\nFig. 3: Hardware Setup working\n\n\n\n\n\nFig. 4: Oscilloscope Trace for BLinking LED\n\n\n\n\n\nFig. 5: RTL Synthesis for the top module\n\n\n\nTestbench Simulation\n\n\n\n\n\n\nFig. n: Waveforms for top module lab1_as\n\n\n\n\n\nFig. n: Waveforms for module drive_led_builtin\n\n\n\n\n\nFig. n: Waveforms for module drive_seven_seg\n\n\n\n\n\nFig. n: Testbench Output for module lab1_as\n\n\n\n\n\nFig. n: Testbench Output for module drive_led_builtin\n\n\n\n\n\nFig. n: Testbench Output for module drive_seven_seg"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI learnt how to use an FPGA and use it to drive external hardware using the GPIO’s, and also learning how to deal with the clock divider using counter was a helpful refresher in my learnings from E85. I spent like approximately 15 hours on this lab. I also found it helpful to work on the testbenches to test my implementation of the hardware."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nUpon entering the given prompt the initial AI generated code had an error as it was trying to load an clock/oscillator module that we were possibly missing, but feeding back the error into Claude, it solved it and generated code that was able to synthesize design as below, it solved the issue my writing that primitive module for clock generation by itself instead of using a library. I confirmed the design its the RTL syntehsis and it seemed good to me. I think it kind of shows that AI is a really powerful tool to use in hardware related projects, especially if used by a person how these things piece together and work, which helps in better interacting with I model and the prompts.\n\n\n\nFig. n: RTL synthesis for AI generated Code"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "I this lab I try to design a system that can read inputs from a 4*4 keypad through debouncing the inputs, and display the entered digits with time multiplexing on a dual seven segment display displaying inputs."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "I this lab I try to design a system that can read inputs from a 4*4 keypad through debouncing the inputs, and display the entered digits with time multiplexing on a dual seven segment display displaying inputs."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nI designed 8 modules in Verilog to implement my hardware on the FPGA, where my top module interfaces with the modules that divide the clock signal into lower frequencies as need, module to have counters keeping track of what keys are pressed, and fsm module that determine which key press to assert and synchronize it to the display, and module to drive the segment enablers and digits.\nMy specific design approach was to power the 4 rows of the keypad one by one on a divide by 4 counter, and then read all the four corresponding column inputs while powering the respective rows, and check if the switch is pressed by looking for a high and increment a counter. My logic for the debouncing of switch press, to detect it accurately was that, if my sampling is fast enough (24Mhz, lower should also work), and the sampling period appropriately small enough chosen (50ms/20Hz), to reset the counters, I can find out which key was pressed, based on the counter with highest value, that would be the actual key pressed, as if any key is pressed later, it would have a lower counter value for being detected as on. The highest counter value is then provided to the keypress detection fsm which when the highest counter is above a certain threshold, it registers it as a valid input, and makes it a locked counter, and outputs a key_pressed pulse, and the key id and gives it to the display moudle. This helps both debounce and synchronize the inputs into our system before they reach the segments. The fsm stays in locked state, untill the locked key has counter value above threshold, and when it goes below threshold it registers it as switch release and thus goes back to idle state to detect new inputs. For the segments, I drive the multiplexer at 240Hz, to enable one segment on clock high and other on low, and then the key pressed pulse, and key_pressed signals from the fsm go to the segment display to update the digits each time a new key press is detected.\nMy calculations for resistor values used in the circuit to connect inputs, seven-segment, and transistors can be found as below.\n\n\n\n\nFig. 1: Calculations for resistor values"
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nBlock Diagram\n\n\n\nFig. 2: Block Diagram for top module “lab3_as”\n\n\n\n\nSchematic\n\n\n\nFig. 3: Schematic for Hardware Setup\n\n\n\n\nState Transition Diagram and Table\n\n\n\nFigure. 4 State Transition Diagram for the keypress detection fsm\n\n\n\n\n\nFigure. 5 State Transition Table for the keypress detection fsm\n\n\n\n\nHDL Code\nCan be found on github repository"
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\n\nFig. 6: Hardware Setup working\n\n\n\nTestbench Simulation Results\n\n\n\nFig. 7: Waveforms for top module lab3_as\n\n\n\n\n\nFig. 8: Waveforms for module clock_divider\n\n\n\n\n\nFig. 9: Waveforms for module power_counter\n\n\n\n\n\nFig. 10: Waveforms for module scan_counter\n\n\n\n\n\nFig. 11: Waveforms for module read_keys\n\n\n\n\n\nFig. 12: Waveforms for module keypress_detection_fsm\n\n\n\n\n\nFig. 13: Waveforms for module seg_enabler\n\n\n\n\n\nFig. 14: Waveforms for module seg_display\n\n\n\n\n\nFig. 15: Testbench output for top module lab3_as\n\n\n\n\n\nFig. 16: Testbench output for module clock_divider\n\n\n\n\n\nFig. 17: Testbench output for module power_counter\n\n\n\n\n\nFig. 18: Testbench output for module scan_counter\n\n\n\n\n\nFig. 19: Testbench output for module read_keys\n\n\n\n\n\nFig. 20: Testbench output for module keypress_detection_fsm\n\n\n\n\n\nFig. 21: Testbench output for module seg_enabler\n\n\n\n\n\nFig. 22: Testbench output for module seg_display"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nI was able to succesfully achieve all the goals for this lab to read all the different key inputs from the 4*4 keypad, with debouncing so that it never double registers a key press, and also doesn’t register multiple keypresses, untill the initially clicked keys are released. I think it was very intresting to think about the debouncing logic and implementing in the hardware, especially how in some places different aspects like paralllelizing the logic can be critical to not violate setup time constrains in case of complexx logic, and other possible synchronization errors that can happen with asynchronous input to the system. I was very happy to be able to make my initial design work in the first attempt itself except some fine tuning for time, and in further labs I would like to think more about making my logic more efficient as well. I spent about 25 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype",
    "href": "labs/lab3/lab3.html#ai-prototype",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Prototype",
    "text": "AI Prototype\nUpon entering the given prompt the initial AI generated code that syntehsized on first go itself, for both the prompts, this shows the versatality of these tools to not only geenrate fresh code, but also use our code, and adapt its logic to build upon it, which is very helpful in real world project development, where nothing is built from scratch but rather a progressive increment on existing work. It is pretty cool to see how easily can AI accelerate the workflow for hardware development related projects. I am attaching below RTL synthesis for the AI geenrated code. It also turns out the synthesis that AI generated was much more resource efficient and used much lesser LUTs onboard, thus it hints that AI could be a great tool to increase efficiency of designs. I also think that the AI is limited in terms of ability to get feedback from real-time deployment of design onto hardware and thus nudge it in terms of timing and other nuance which it might lack.\n\n\n\n\nFig. 23: RTL synthesis for AI generated Code"
  },
  {
    "objectID": "posts/initial-reflections.html",
    "href": "posts/initial-reflections.html",
    "title": "Initial Reflections",
    "section": "",
    "text": "MicroPs is a class that I had been looking forward to since almost a year ago when I took E85, especially because I have been very passionate about building hardware and electornics projects with IoT. While I have worked with embedded systems before, I don’t think I before coming to Mudd, I got the actual understanding of how the libraries or even the actual microprocessors worked, I just knew how to use them to do what I need to do, without acutally understanding their actual mechanism. I feel like one of my goals from this course, is to be able to get that in-depth understanding of the working of microcontroller, especially after having taken E85, and also build fun projects, that involves application of my skills. I am looking forward to also take-up a project that will involve my understanding of microprocessors, and apply it to do a project which is intersectional, and can be possibly used in ecological sensing. I am also not taking a lot of classes this semester, so that I can focus on quality over quantity, and get good grasp over what I learn and also enjoy this process. Looking forward to what this course and semester entails."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Aabhas Senapati is a Junior at Harvey Mudd College, pursuing Independent Program of Study in Ecology, Electronics and Sensing."
  }
]